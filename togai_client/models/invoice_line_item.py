# coding: utf-8

"""
    Togai Apis

    APIs for Togai App

    The version of the OpenAPI document: 1.0
    Contact: engg@togai.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class InvoiceLineItem(BaseModel):
    """
    InvoiceLineItem
    """ # noqa: E501
    id: Optional[StrictStr] = None
    description: StrictStr
    type: StrictStr = Field(description="Type of the line item - GRAND_TOTAL_AMOUNT: Sum of all total amount of individual invoices in a grouped(composite) invoice - TOTAL_AMOUNT: Total revenue of the invoice - NET_AMOUNT: Net revenue of the invoice ( Gross revenue - Discounts ) - GROSS_AMOUNT: Gross revenue of the invoice  - PRICE_PLAN_AMOUNT: SUB_TOTAL_AMOUNT + true up amount - SUB_TOTAL_AMOUNT: Sum of all rate card revenues - TRUE_UP_AMOUNT: Minimum commitment - SUB_TOTAL_AMOUNT (Always positive) - TOTAL_USAGE: List of all the usage meter usages - USAGE_METER_USAGE: Usage of an usage meter - USAGE_RATE_CARD_AMOUNT: Revenue generated from usage rate card - USAGE_RATE_CARD_SLAB_AMOUNT: Revenue generated from usage rate card slab - FIXED_FEE_RATE_CARD_AMOUNT: Revenue generated from fixed fee rate card - CREDIT_GRANT_RATE_CARD_AMOUNT: : Revenue generated from credit grant rate card - BILLING_ENTITLEMENT_RATE_CARD_AMOUNT: Revenue generated from billing entitlement rate card - ENTITLEMENT_OVERAGE_RATE_CARD_AMOUNT: : Revenue generated from entitlement overage rate card - ENTITLEMENT_OVERAGE_RATE_CARD_SLAB_AMOUNT: Revenue generated from entitlement overage rate card slab - LICENSE_RATE_CARD_AMOUNT: Revenue generated from license rate card - TOTAL_CREDITS: Sum of all credit amounts - SUB_CREDITS: Granted credit value - TOTAL_ADVANCED_FEES: Sum of all advanced fee revenue - ADVANCED_FIXED_FEE: Revenue generated from advanced fixed fee rate card - ADVANCED_LICENSE_RATE_CARD_AMOUNT: Revenue generated from advanced license rate card - ADVANCED_BILLING_ENTITLEMENT_RATE_CARD_AMOUNT: Revenue generated from advanced billing entitlement rate card - ADVANCED_CREDIT_GRANT_RATE_CARD_AMOUNT: Revenue generated from advanced credit grant rate card - TOTAL_MISCELLANEOUS_CHARGES: Net revenue of all MISCELLANEOUS_CHARGE - MISCELLANEOUS_CHARGE: Custom amount added to a DRAFT invoice - TOTAL_PURCHASE_AMOUNT: Net revenue all rate cards in a purchase plan - CUSTOM_AMOUNT: Custom amount added a DRAFT invoice - CUSTOM_TAG: User defined tags given to each rate card - TOTAL_PRICING_RULE_ADDITION_AMOUNT: Sum of all line items added by applying pricing rules - PRICING_RULE_ADDITION_AMOUNT: Amount added to invoice as a result of applying a pricing rule - PRICING_RULE_REVENUE_UPDATE_AMOUNT: Difference in revenue(value) obtained as a result of applying a pricing rule - PRICING_RULE_USAGE_UPDATE_AMOUNT: Difference in usage(quantity) obtained as a result of applying a pricing rule - RATE_CONFIG_ADJUSTMENT_AMOUNT: Difference in revenue obtained as a result of applying rate config['minimumRate', 'maximumRate'] at rate card level ")
    value_per_quantity: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="valuePerQuantity")
    quantity: Optional[Union[StrictFloat, StrictInt]] = None
    units: Optional[StrictStr] = None
    value: Union[StrictFloat, StrictInt]
    metadata: Optional[Dict[str, Any]] = None
    line_items: Annotated[List[InvoiceLineItem], Field(min_length=1, max_length=50)] = Field(alias="lineItems")
    __properties: ClassVar[List[str]] = ["id", "description", "type", "valuePerQuantity", "quantity", "units", "value", "metadata", "lineItems"]

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['TOTAL_USAGE', 'USAGE_METER_USAGE', 'GRAND_TOTAL_AMOUNT', 'TOTAL_AMOUNT', 'NET_AMOUNT', 'GROSS_AMOUNT', 'SUB_TOTAL_AMOUNT', 'PRICE_PLAN_AMOUNT', 'FIXED_FEE_RATE_CARD_AMOUNT', 'CREDIT_GRANT_RATE_CARD_AMOUNT', 'BILLING_ENTITLEMENT_RATE_CARD_AMOUNT', 'ENTITLEMENT_OVERAGE_RATE_CARD_AMOUNT', 'ENTITLEMENT_OVERAGE_RATE_CARD_SLAB_AMOUNT', 'LICENSE_RATE_CARD_AMOUNT', 'USAGE_CYCLE_AMOUNT', 'LICENSE_RATE_CARD_SLAB_AMOUNT', 'USAGE_RATE_CARD_AMOUNT', 'USAGE_RATE_CARD_SLAB_AMOUNT', 'TOTAL_CREDITS', 'SUB_CREDITS', 'TOTAL_ADVANCED_FEES', 'ADVANCED_FIXED_FEE', 'ADVANCED_LICENSE_RATE_CARD_AMOUNT', 'ADVANCED_BILLING_ENTITLEMENT_RATE_CARD_AMOUNT', 'ADVANCED_CREDIT_GRANT_RATE_CARD_AMOUNT', 'TOTAL_MISCELLANEOUS_CHARGES', 'MISCELLANEOUS_CHARGE', 'TRUE_UP_AMOUNT', 'TOTAL_PURCHASE_AMOUNT', 'CUSTOM_AMOUNT', 'CUSTOM_TAG', 'TOTAL_PRICING_RULE_ADDITION_AMOUNT', 'PRICING_RULE_ADDITION_AMOUNT', 'PRICING_RULE_REVENUE_UPDATE_AMOUNT', 'PRICING_RULE_USAGE_UPDATE_AMOUNT', 'RATE_CONFIG_ADJUSTMENT_AMOUNT', 'TOTAL_TAX_AMOUNT', 'TAX_AMOUNT', 'PROXY_AMOUNT']):
            raise ValueError("must be one of enum values ('TOTAL_USAGE', 'USAGE_METER_USAGE', 'GRAND_TOTAL_AMOUNT', 'TOTAL_AMOUNT', 'NET_AMOUNT', 'GROSS_AMOUNT', 'SUB_TOTAL_AMOUNT', 'PRICE_PLAN_AMOUNT', 'FIXED_FEE_RATE_CARD_AMOUNT', 'CREDIT_GRANT_RATE_CARD_AMOUNT', 'BILLING_ENTITLEMENT_RATE_CARD_AMOUNT', 'ENTITLEMENT_OVERAGE_RATE_CARD_AMOUNT', 'ENTITLEMENT_OVERAGE_RATE_CARD_SLAB_AMOUNT', 'LICENSE_RATE_CARD_AMOUNT', 'USAGE_CYCLE_AMOUNT', 'LICENSE_RATE_CARD_SLAB_AMOUNT', 'USAGE_RATE_CARD_AMOUNT', 'USAGE_RATE_CARD_SLAB_AMOUNT', 'TOTAL_CREDITS', 'SUB_CREDITS', 'TOTAL_ADVANCED_FEES', 'ADVANCED_FIXED_FEE', 'ADVANCED_LICENSE_RATE_CARD_AMOUNT', 'ADVANCED_BILLING_ENTITLEMENT_RATE_CARD_AMOUNT', 'ADVANCED_CREDIT_GRANT_RATE_CARD_AMOUNT', 'TOTAL_MISCELLANEOUS_CHARGES', 'MISCELLANEOUS_CHARGE', 'TRUE_UP_AMOUNT', 'TOTAL_PURCHASE_AMOUNT', 'CUSTOM_AMOUNT', 'CUSTOM_TAG', 'TOTAL_PRICING_RULE_ADDITION_AMOUNT', 'PRICING_RULE_ADDITION_AMOUNT', 'PRICING_RULE_REVENUE_UPDATE_AMOUNT', 'PRICING_RULE_USAGE_UPDATE_AMOUNT', 'RATE_CONFIG_ADJUSTMENT_AMOUNT', 'TOTAL_TAX_AMOUNT', 'TAX_AMOUNT', 'PROXY_AMOUNT')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of InvoiceLineItem from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in line_items (list)
        _items = []
        if self.line_items:
            for _item_line_items in self.line_items:
                if _item_line_items:
                    _items.append(_item_line_items.to_dict())
            _dict['lineItems'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of InvoiceLineItem from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "description": obj.get("description"),
            "type": obj.get("type"),
            "valuePerQuantity": obj.get("valuePerQuantity"),
            "quantity": obj.get("quantity"),
            "units": obj.get("units"),
            "value": obj.get("value"),
            "metadata": obj.get("metadata"),
            "lineItems": [InvoiceLineItem.from_dict(_item) for _item in obj["lineItems"]] if obj.get("lineItems") is not None else None
        })
        return _obj

# TODO: Rewrite to not use raise_errors
InvoiceLineItem.model_rebuild(raise_errors=False)

